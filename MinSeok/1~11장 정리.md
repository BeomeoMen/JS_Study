# 4장 변수

## 변수(Variable)
- 변수는 하나의 값을 저장하기 위해 확보한 `메모리 공간 자체` 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다. 

- `값의 위치`를 가르키는 상징적인 이름이다. 

### 메모리 저장 방식
- 변수 선언 / 값의 할당 / 값의 재할당

![](https://velog.velcdn.com/images/narcoker/post/8422ce98-77b6-4dd4-9238-af7da71f0ea2/image.png)
<br>

### 자바스크립트 변수 선언 
- **선언 단계** 
    - 변수 이름을 통해 자바스크립트 엔진에 변수의 존재를 알린다. 
- **초기화 단계** 
    - 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다. 
<br>

### 변수 호이스팅
- 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트의 특징

### 네이밍 컨벤션
- 카멜케이스(camelCase)
    - 변수나 함수의 이름 등
- 스네이크 케이스(snake_case) 
    - ECMAScript 사양에 정의되어 있는 객체와 함수 등
- 파스칼 케이스(PascalCase)
    - 생성자 함수, 클래스의 이름 등

---
<br>

## 5장 표현식과 문

### 값(value)
- `식(표현식)이 평가되어 생성된 결과`를 말한다. 
- 변수는 `하나의 값`을 저장하기 위해 확보한 메모리 공간 자체 또는 메모리 공간을 식별하기 위해 붙인 이름 
- 변수에 할당되는 것은 `값`

### 리터럴(Literal)
- `사람이 이해`할 수 있는 `문자 또는 약속된 기호`를 사용해 `값을 생성하기 표기법`
    - 숫자(정수, 부동소수점, 2진수 등등)
    - 문자열
    - 불리언
    - null
    - undefined
    - 객체
    - 배열
    - 함수
    - 정규 표현식 등의 종류 

### 표현식(Expression)
- `값으로 평가될 수 있는 문(statement)`이다. 
- 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다. 
- 값으로 평가될 수 있는 문은 모두 표현식이다.

### 문(Statement)
- 프로그램을 구성하는 `기본 단위`이자 `최소 실행 단위`이다. 
- 문은 여러 **토큰(token)**으로 구성된다.
    - 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 `코드의 기본 요소`를 의미

### 표현식인 문과 표현식이 아닌 문
- 표현식은 문의 일부 일 수 있고, 그 자체로 문이 될 수도 있다. 
- 구별하는 가장 좋은 방법
    - `변수에 할당`해 보는 것
    - 표현식인 문은 값으로 평가되므로 변수에 할당할 수 있다.
    - 표현식이 아닌 문은 값으로 평가할 수 없으므로 변수에 할당할 수 없다. 

```javascript
// 변수 선언문은 표현식이 아닌 문이다.
var x;

// 할당문은 그 자체가 표현식이지만 완전한 문이기도 하다. 즉 할당문은 표현식이다.
x = 100;

// 표현식이 아닌 문은 값처럼 사용할 수 없다.
var foo = var x; // SyntaxError : Unexpected token var
```

---
<br>

## 6장 데이터 타입 
- 원시 타입
    - 숫자(number) : 정수, 숫자, 실수 구분 X
    - 문자열(string) : 문자열 
    - 불리언(boolean) : true, false
    - indefined : var 키워드로 선언된 변수에 암묵적으로 할당되는 값
    - null : 값이 없다는 것을 의도적으로 명시할 때 사용하는 값
    - 심벌 (symbol) : ES6에서 추가된 7번째 타입
- 객체 타입 
    - 객체 
    - 함수
    - 배열 등

### 템플릿 리터럴 
- ES6에서 추가된 새로운 문자열 표기법
- 런타임에 일반 문자열로 변환되어 처리된다.
- `백틱(``)`을 사용해 표현한다. 
- **장점**
    - 이스케이프 시퀀스를 사용하지 않고도 줄바꿈이 허용되며, 공백도 있는대로 적용된다.
    - 표현식 삽입을 통해 문자열 삽입 가능

```javascript
var first = 'Ung-mo';
var last = 'Lee';

// ES6 표현식 삽입
console.log(`My name is ${first} ${last}`) // My name is Ung-mo Lee
```

### 심벌 타입
- 다른 값과 중복되지 않는 유일무이한 값이다.
- 주로 이름이 충돌할 위험이 없는 객체의; 유일한 프로퍼티 키를 만들기 위해 사용한다.
- Symbol 함수를 호출해 생성한다.

### 데이터 타입이 필요한 이유 
- 값을 저장할 때 확보해야 하는 `메모리 공간의 크기`를 결정하기 위해
- 값을 참조할 때 한 번에 읽어 등여야 할 `메모리 공간의 크기`를 결정하기 위해
- 메모리에 읽어 들인 2진수를 `어떻게 해석`할지 결정하기 위해 

### 동적 타이핑과 정적 타이핑
- 정적 타입 언어
    - 변수를 `선언`할 때 변수에 할당할 수 있는 값의 종류, 즉 데이터 타입을 `사전에 선언`해야 한다.

- 자바스크립트는 선언이 아닌 `할당에 의해 타입이 결정(타입 추론)`된다.
- 재할당에 의해 변수의 타입은 언제든 동적으로 변할 수 있다. : **동적 타이핑**

---
<br>

## 7장 연산자

### 비교 연산자
- 동등 비교(==)
    - 좌항과 우항의 피 연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 `타입을 일치시킨 후 같은 값인지 비교`
- 일치 비교(===)
    - 연산자는 좌항과 우항의 피연산자가 `타입도 같고 값도 같은 경우`에 한하여 true를 반환한다. 

### 논리 연산자
|논리 연산자|의미|
|---|---|
|  |논리합(OR)|
|&&|논리곱(AND)|
|!|부정(NOT)|

---
<br>

## 8장 제어문

### 블록문
- 0개 이상의 문을 `중괄호로 묶은 것`으로, 코드 블록 또는 블록이라고 부르기도 한다. 

### 조건문
- 자바스크립트는 if ... else문과 switch 문으로 두 가지 조건문을 제공한다. 
- if ... else문은 삼항 연산자로 바꿔 쓸 수 있다.
- 코드 블록 내의 문이 하나뿐이라면 중괄호를 생략할 수 있다.

### 반복문
- for 문
    - 조건식이 거짓으로 평가될 때까지 코드 블록을 반복 실행한다.

- while 문
    - 주어진 조건식의 평가 결과가 참이면 코드 블록을 계속해서 바나복 실행한다.

- do ... while문 
    - 코드 블록을 먼저 실행하고 조건식을 평가한다. 

```javascript
var count = 0;

// count가 3보다 작을 때까지 코드 블록을 계속 반복 실행한다.
do {
  console.log(count); // 0 1 2
  count++;
} while (count < 3);
```

- breack 문
  - break문은 코드블록을 탈출한다.
  - 중첩도니 for문의 내부 for문에서 break문을 실행하면 내부 for문을 탈출 외부 for문으로 진입한다.

- continue 문
  - 반복문의 `코드 블록 실행을 현 지점에서 종료`하고 반복문의 증감식으로 실행 흐음을 이동시킨다. 

---
<br>

## 9장 타입 변환과 단축 평가
- 명시적 타입 변환
  - 개발자가 의도적으로 값의 타입을 변환하는 것 

- 암묵적 타입 전환
  - 개발자의 의도와 상관없이 표현식을 평가하는 도움 암움적으로 타입이 자동변환되는 것

---
<br>

## 10장 객체 리터럴

### 객체 
- 자바스크립트는 객체 기반의 프로그래밍 언어이다. 자바스크립트를 구성하는 거의 "모든 것"이 객체이다. 
- **객체** 
  - `0개 이상의 프로퍼티로 구성된 집합` 
- **프로퍼티** 
  - `키와 값`으로 구성된다.
  - `객체의 상태를 나타내는 값(data)`

![](https://velog.velcdn.com/images%2Fseeh_h%2Fpost%2F5808a553-e869-4a38-8d1a-ec921f028085%2Fimage.png)

- **메서드(method)** 
  - 프로퍼티(상태 데이터)를 참조하고 조작할 수있는 동작(behavior)
  - `프로퍼티 값이 함수일 경우` 일반 함수와 구별하기 위해 `메서드`라 부른다.

![](https://images.velog.io/images/5o_hyun/post/f2496946-827c-49ca-8fc8-ca837241622c/Untitled-1.jpg)

<br>

### 객체 리터럴에 의한 객체 생성
- `자바스크립트`는 `프로토타입 기반 객체 지향 언어`로서 클래스 기반 객체 지향 언어와는 달리 `다양한 객체 생성 방법`을 지원한다.
  - 객체 리터럴
  - Object 생성자 함수
  - 생성자 함수
  - Object.create 메서드
  - 클래스(ES6)

- **객체 리터럴**

  - 중괄호({...}) 내에 0개 이상의 프로퍼티를 정의한다. 

  - 변수에 할당되는 시점에 자바스크립트 엔진은 객체 리터럴을 해석해 객체를 생성한다.

  - 객체 리터럴에 프로퍼티를 포함시켜 객체를 생성함과 동시에 프로퍼티 생성 가능, 생성후 동적 추가 가능

```javascript
var person = {
  name : 'Lee',
  sayHello: function () {
    console.log(`Hello! My name is ${this.name}.`);
  }
}

console.log(typeof person) // object
console.log(person) // { name : 'Lee', sayHello : f }
```
<br>

### 프로퍼티
- **객체**는 `프로퍼티의 집합`이며, **프로퍼티**는 `키와 값으로 구성된다.`
  - 프로퍼티 키 :
    - 빈 문자열을 포함하는 모든 문자열 또는 심벌값
  - 프로퍼티 값 : 
    - 자바스크립트에서 사용하는 모든 값

<br>

### 메서드
- 자바스크립트의 함수는 객체(일급 객체)이기 때문에 함수를 값으로 취급 가능하다.
- `프로퍼티의 값이 함수일 경우 일반함수와 구분하기 위해` 메서드

<br>

### 프로퍼티 접근
- 마침표 표기법(.)
- 대괄호 표기법([ ... ])

```javascript
var person = {
  name : 'Lee'
};

// 마침표 표기법
console.log(person.name) // Lee

// 대괄호 표기법
console.log(person['name']) // Lee

```
- 이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값 갱신

- 존재하지 않는 프로퍼티에 값을 할당하면 동적 생성, 할당
- delete 연산자를 통해 객체의 프로퍼티 삭제 가능

```javascript
var person = {
  name : 'Lee'
}

person.age = 20;
console.log(person) // { name : 'Lee', age : 20 }

delete person.age;
console.log(person) // { name : 'Lee' }
```

<br>

### ES6에서 추가된 객체 리터럴의 확장 기능

#### 프로퍼티 축약 표현
- `프로퍼티 값으로 변수`를 사용하는 경우, `변수 이름과 프로퍼티 키가 동일`한 이름일 때, `프로퍼티를 생략`할 수 있다.
```javascript
let x = 1, y = 2;

// 프로퍼티 축약 표현
const obj = { x, y }

console.log(obj); //{ x: 1, y : 2 }
```

#### 메서드 축액 펴햔
- 메서드를 정의하라 때 function 키워드를 생략한 축약표현이 사용가능

<br>

## 11장 원시 값과 객체의 비교

### 원시 값
- 변경 불가능한 값 
  - 변경 불가능하다는 것은 변수가 아닌 값에 대한 얘기
  - 변수 값을 변경할 수 없는 것은 아니다.
- 변수에는 `실제 값`이 저장된다.
![](https://velog.velcdn.com/images/dy6578ekdbs/post/3b2fae81-c87e-48a3-9cf0-e21ac948f4d3/image.png)

<br>

- **유사 배열 객체**
  - 배열처럼 인덱스로 접근가능, length 프로퍼티를 갖는 객체
  <br>-> 문자열에서 인덱스로 접근가능

<br>

- **값의 의한 전달**
  - 메모리 주소를 전달한다. 
  - 전달된 메모리 주소를 통해 메모리 공간에 접근해 값을 참고한다.
  - 두 변수의 원시 값은 `서로 다른 메모리 공간에 저장`된 `별개의 값`이 되어 `한쪽이 재할당`을 통해 값을 변경하더라도 `서로 간섭할 수 없다.`


### 객체
- 변경 가능한 값
- 변수에는 `참조값`이 저장된다.
  - 생성된 객체가 저장된 메모리 공간의 주소, 그 자체

![](https://velog.velcdn.com/images/kozel/post/31738528-08ce-43c4-bb41-3ae672590f92/image.jpeg)

<br>

- **참조에 의한 전달**
  - 저장된 메모리 주소는 다르지만 동일한 참조 값을 받는다.
  - **두 개의 식별자가 하나의 객체를 공유**
  - 서로 영향을 주고 받는다
